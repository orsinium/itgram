---
title: 375
date: 2019-12-24 16:44:57
tags: []
layout: post
---

Если у вас в проекте `Dockerfile`, `Makefile`, `docker-compose.yml`, shell-скрипты, да ещё всё это дёргается в `gitlab-ci.yml`, то можно из этой схемы немножко повыкидывать лишнее. Поможет в этом [Gitlab Runner](https://docs.gitlab.com/runner/), который на удивление просто установить и использовать. В общем, [скачиваем бинарник](https://docs.gitlab.com/runner/install/), и установка закончена. Вот она, мощь Go.

Выполнить job (дальше буду задачей называть) без изоляции, в текущем окружении, с игнорированием `image` и прочиъ докеровских штучек (`flake8` в примере — имя задачи):

```gitlab-runner exec shell flake8```

Выполнить job внутри docker'а, используя `image`, `services`, вот это вот всё:

```sudo gitlab-runner exec docker --docker-privileged flake8```

Многие фичи недоступны, рекомендую почитать [Limitations of gitlab-runner exec](https://docs.gitlab.com/runner/commands/#limitations-of-gitlab-runner-exec). Главное, что выполняется только одна задача, без предыдущих, соседних, вот этого всего. А ещё артифакты не сохраняются. В общем, есть issue [gitlab-runner exec usability improvements](https://gitlab.com/gitlab-org/gitlab-runner/issues/2226), в нём 2 года обсуждают, как всё это сильно улучшить, но пока что как есть.

Если нужно добавить какие-то задачи, которые не должны исполняться на CI, можно указать в их конфиге `when: manual`. Преимущество перед make в том, что можно не только из консоли запускать, но и через интерфейс Gitlab прям со страницы PR'а.

Вообще, преимуществ, по сравнению с make, довольно много: MIT лицензия, лёгкая установка, активная разработка, красивый и понятный конфиг, написан на Go, нету десятка разных диалектов. Так что если описанные ограничения для проекта не актуальны — do it!
